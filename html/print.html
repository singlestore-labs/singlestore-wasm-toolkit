<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SingleStore Wasm Toolkit</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Tutorial-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="Tutorial-Setup.html"><strong aria-hidden="true">2.</strong> Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Setup-Container.html"><strong aria-hidden="true">2.1.</strong> With a Development Container</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Setup-Container-VSCode.html"><strong aria-hidden="true">2.1.1.</strong> VS Code Container</a></li><li class="chapter-item expanded "><a href="Tutorial-Setup-Container-Standalone.html"><strong aria-hidden="true">2.1.2.</strong> Standalone Container</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-Setup-Local.html"><strong aria-hidden="true">2.2.</strong> Locally</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-Examples.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li class="chapter-item expanded "><a href="Tutorial-WIT.html"><strong aria-hidden="true">4.</strong> Writing WIT IDL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-WIT-Power.html"><strong aria-hidden="true">4.1.</strong> WIT for the power-of Example</a></li><li class="chapter-item expanded "><a href="Tutorial-WIT-Split.html"><strong aria-hidden="true">4.2.</strong> WIT for the split-str Example</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-Impl.html"><strong aria-hidden="true">5.</strong> Implementation and Compilation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Impl-CPP.html"><strong aria-hidden="true">5.1.</strong> Using C/C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Impl-CPP-Power.html"><strong aria-hidden="true">5.1.1.</strong> For the power-of Example</a></li><li class="chapter-item expanded "><a href="Tutorial-Impl-CPP-Split.html"><strong aria-hidden="true">5.1.2.</strong> For the split-str Example</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-Impl-Rust.html"><strong aria-hidden="true">5.2.</strong> Using Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Impl-Rust-Power.html"><strong aria-hidden="true">5.2.1.</strong> For the power-of Example</a></li><li class="chapter-item expanded "><a href="Tutorial-Impl-Rust-Split.html"><strong aria-hidden="true">5.2.2.</strong> For the split-str Example</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-Test.html"><strong aria-hidden="true">6.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Test-Power.html"><strong aria-hidden="true">6.1.</strong> Testing the power-of Example</a></li><li class="chapter-item expanded "><a href="Tutorial-Test-Split.html"><strong aria-hidden="true">6.2.</strong> Testing the split-str Example</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-Deploy.html"><strong aria-hidden="true">7.</strong> Deployment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Deploy-Power.html"><strong aria-hidden="true">7.1.</strong> Deploying the power-of Example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Deploy-Power-Push.html"><strong aria-hidden="true">7.1.1.</strong> Using pushwasm</a></li><li class="chapter-item expanded "><a href="Tutorial-Deploy-Power-Cloud.html"><strong aria-hidden="true">7.1.2.</strong> From Cloud Storage</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-Deploy-Split.html"><strong aria-hidden="true">7.2.</strong> Deploying the split-str Example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Deploy-Split-Push.html"><strong aria-hidden="true">7.2.1.</strong> Using pushwasm</a></li><li class="chapter-item expanded "><a href="Tutorial-Deploy-Split-Cloud.html"><strong aria-hidden="true">7.2.2.</strong> From Cloud Storage</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-Running.html"><strong aria-hidden="true">8.</strong> Running In the Database</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Tutorial-Running-Power.html"><strong aria-hidden="true">8.1.</strong> Running the power_of UDF</a></li><li class="chapter-item expanded "><a href="Tutorial-Running-Split.html"><strong aria-hidden="true">8.2.</strong> Running the split_str TVF</a></li></ol></li><li class="chapter-item expanded "><a href="Tutorial-WrapUp.html"><strong aria-hidden="true">9.</strong> Wrap-Up</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SingleStore Wasm Toolkit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This tutorial will teach you how to write WebAssembly (Wasm) UDFs in in C/C++ and Rust, load them into SingleStoreDB, and evaluate them in queries.</p>
<p>Let's get started by learning how to <a href="./Tutorial-Setup.html">setup our environment</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>For each example in this tutorial, it will be useful to create yourself a separate work directory in which to put your code and compiled artifacts. This will help keep your files for each example organized.</p>
<p>In addition to a SQL client and SingleStore database, you’ll need a few other things to get your environment set up properly. For this, you have some options:</p>
<ul>
<li>Use a <a href="Tutorial-Setup-Container.html">development container</a> (recommended)</li>
<li>Install development dependencies <a href="Tutorial-Setup-Local.html">locally</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-a-development-container"><a class="header" href="#setting-up-a-development-container">Setting Up a Development Container</a></h1>
<p>If you have a container runtime (e.g. Docker) available to you, the easiest way to get started is to utilize one of our prebuilt Wasm development containers.  To do this, first clone or download the <a href="https://github.com/singlestore-labs/singlestore-wasm-toolkit">SingleStore WASM Toolkit</a> repository:</p>
<pre><code>git clone git@github.com:singlestore-labs/singlestore-wasm-toolkit.git
</code></pre>
<p>The development containers provided in this repo contain all of the tools you'll need to write, build, and deploy Wasm UDFs.  Additionally, the repo also includes many examples, including fully-written versions of the examples referenced in this tutorial.  You may choose from the following containers, depending on your preferred workflow:</p>
<ul>
<li><a href="Tutorial-Setup-Container-VSCode.html">Visual Studio Code</a></li>
<li><a href="Tutorial-Setup-Container-Standalone.html">Standalone</a></li>
</ul>
<p>The exact setup for each of these is described in their respective sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vs-code-development-container-setup"><a class="header" href="#vs-code-development-container-setup">VS Code Development Container Setup</a></h1>
<p>This container is designed to integrate natively into VS Code using the Remote Containers extension.  VS Code an IDE framework that is usable run on Mac, Windows, or Linux, and can be downloaded <a href="https://code.visualstudio.com/download">here</a>.</p>
<blockquote>
<p><strong>Note</strong>
<em>MacOS Users</em>:  VS Code is usable on both x64 and M1 Macs.  One way to install it for MacOS is to use the package manager <em>brew</em>.  To get <em>brew</em>, please follow the instuctions <a href="https://brew.sh/">here</a>.  When you have <em>brew</em>, run <code>brew install --cask visual-studio-code</code> to obtain VS Code.</p>
</blockquote>
<ol>
<li>
<p>Ensure that VS Code is installed, and the <em>wasm-toolkit</em> repository has been cloned.</p>
</li>
<li>
<p>In VS Code, install the <em>Remote - Containers VS Code Extension</em> if you do not already have it.</p>
</li>
<li>
<p>In VS Code, type F1 and search for “Open Folder in Container”.</p>
</li>
<li>
<p>Navigate to the directory where you cloned the <em>wasm-toolkit</em> repo, and click Open.</p>
</li>
<li>
<p>VS Code will now build the container, which may take quite a while.</p>
</li>
</ol>
<p>When the container build has completed, you should see <em>wasm-toolkit</em> repository's file tree appear in the <em>EXPLORER</em> panel on the left side of the VS Code window.  For the purposes of this tutorial, it will be most convenient if you store your code in a directory relative to the repository.  Here's one way to do this:</p>
<ol>
<li>
<p>Right-click on the empty space in the EXPLORER panel, and select <code>New Folder</code>.</p>
</li>
<li>
<p>Type <code>wasm-tutorial</code> and press Enter.  There should now be a sub-folder by this name in the tree.  Put any files you create in here.</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>
As you work through this tutorial, please be sure to execute your commands <em>inside the VS Code terminal window</em> so that you have access to the necessary tools.</p>
</blockquote>
<p>Next, let's pick an <a href="Tutorial-Examples.html">example</a> to work through.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standalone-container-setup"><a class="header" href="#standalone-container-setup">Standalone Container Setup</a></h1>
<p>This container provides a standalone shell environment configured with a variety of Wasm development tools.  It will mount the directory of your choosing.</p>
<ol>
<li>
<p>Ensure that the <em>wasm-toolkit</em> repository has been cloned.</p>
</li>
<li>
<p>Create a subdirectory for the code in this tutorial.  This can be anywhere.  For the purposes of this tutorial, we'll assume it is in <code>/home/$USER/wasm-tutorial</code>.</p>
</li>
<li>
<p>At your command prompt, change to the root directory of the <em>wasm-toolkit</em> repository and type <code>scripts/dev-shell /home/$USER/wasm-tutorial</code>.  Ensure that the argument reflects the actual path of the directory you created in the above step.</p>
</li>
<li>
<p>You should now see the following prompt:</p>
</li>
</ol>
<pre><code>[dev-shell]:~/src %
</code></pre>
<p>The <code>src</code> directory has been mounted from <code>/home/$USER/wasm-tutorial</code> (or whatever alternative directory you specified in step 3).  It is <em>not</em> necessary to write the code for this tutorial inside the container's shell; you may use your preferred editing workflow for this.  However, please <em>do</em> be sure to run all suggested build and deployment commands inside the container's shell so that you have access to the necessary tools.</p>
<p>Next, let's pick an <a href="Tutorial-Examples.html">example</a> to work through.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-setup"><a class="header" href="#local-setup">Local Setup</a></h1>
<p>If you do not wish to use a development container and/or you’d prefer to set up your development environment on your local system, you’ll need to do the following:</p>
<ul>
<li>
<p>Download the <a href="https://github.com/WebAssembly/wasi-sdk/releases">WASI SDK</a> and decompress it somewhere.  Ensure that your <code>$PATH</code> variable is prefixed with this location when you are running the build commands suggested in this tutorial.  For example, assuming you installed the WASI SDK in <code>/opt/wasi-sdk</code>, at the command prompt, you can type (assuming your are using <code>bash</code>/<code>zsh</code>):</p>
<ul>
<li><code>export PATH=/opt/wasi-sdk/bin:$PATH</code></li>
</ul>
</li>
<li>
<p>Download and install the Rust toolchain:</p>
<ul>
<li>
<p><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p>
</li>
<li>
<p><code>source $HOME/.cargo/env</code></p>
</li>
</ul>
</li>
<li>
<p>Download and install the wit-bindgen program:</p>
<ul>
<li><code>cargo install --git https://github.com/bytecodealliance/wit-bindgen wit-bindgen-cli</code></li>
</ul>
</li>
<li>
<p><em>(Optional)</em> If you would like to use the testing tool <a href="https://github.com/singlestore-labs/writ"><code>writ</code></a> and the deployment tool <a href="https://github.com/singlestore-labs/pushwasm"><code>pushwasm</code></a>, please follow the installation instructions in their respective repositories and ensure they are in your <code>$PATH</code>.</p>
</li>
</ul>
<p>Next, let's pick an <a href="Tutorial-Examples.html">example</a> to work through.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>In this tutorial, we'll walk you through two different examples.</p>
<h2 id="power-of"><a class="header" href="#power-of"><code>power-of</code></a></h2>
<p>This is a very small example that will show you the basics of creating a Wasm UDF.  In it, we will develop a program that computes x^y (that is, &quot;x to the power of y&quot;).</p>
<p>You can get started on this tutorial <a href="Tutorial-WIT-Power.html">here</a>.</p>
<h2 id="split-str"><a class="header" href="#split-str"><code>split-str</code></a></h2>
<p>This is a more advanced example in which we will write a Wasm TVF that splits a string into substring given a delimiting character.  It will show you how to develop a Wasm function that accepts and returns complex structures such as strings and records.</p>
<p>You can get started on this tutorial <a href="Tutorial-WIT-Split.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-wit-specification"><a class="header" href="#creating-a-wit-specification">Creating a WIT Specification</a></h1>
<ul>
<li>To see how to create a WIT specification for the <code>power-of</code> example, please look <a href="Tutorial-WIT-Power.html">here</a>.</li>
<li>To see how to create a WIT specification for the <code>split-str</code> example, please look <a href="Tutorial-WIT-Split.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED FILE; DO NOT CHANGE! -->
<h1 id="creating-a-wit-specification-for-the-power-of-example"><a class="header" href="#creating-a-wit-specification-for-the-power-of-example">Creating a WIT Specification for the <code>power-of</code> Example</a></h1>
<p>Before we do any coding, let’s first define our interface. WIT is an Interface Definition Language (IDL) used to describe Wasm modules.  It is provided in files with the <code>.wit</code> extension.</p>
<p>This example will compute x^y (that is, &quot;x to the power of y&quot;).</p>
<p>In a new work directory, create a new file called <code>power.wit</code> in your text editor, and add this content:</p>
<pre><code class="language-wit">power-of: func(b: s32, exp: s32) -&gt; s32
</code></pre>
<p>This function will take two signed 32-bit integers as arguments (the base <code>b</code> and the exponent <code>exp</code>) and return a single, signed 32-bit integer.</p>
<p>Go ahead and save the file.</p>
<p>Now we’re ready to write some code.</p>
<ul>
<li>If you'd like to learn about implementing this example in C, please look <a href="Tutorial-Impl-CPP-Power.html">here</a>.</li>
<li>If you'd like to learn about implementing this example in Rust, please look <a href="Tutorial-Impl-Rust-Power.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED FILE; DO NOT CHANGE! -->
<h1 id="creating-a-wit-specification-for-the-split-str-example"><a class="header" href="#creating-a-wit-specification-for-the-split-str-example">Creating a WIT Specification for the <code>split-str</code> Example</a></h1>
<p>Before we do any coding, let’s first define our interface. WIT is an Interface Definition Language (IDL) used to describe Wasm modules.  It is provided in files with the <code>.wit</code> extension.</p>
<p>In this example, we’ll work with strings and nested types. Let’s create a function that takes a string, splits it at every occurrence of a delimiting string, and then returns each sub-string along with its starting indices. The output will be sent back as a list of records (aka structures).</p>
<p>To start, let’s create a new work directory, and inside of it we’ll make a new file called <code>split.wit</code>. The WIT IDL we need is below, so we can go ahead and paste that in and save it.</p>
<pre><code class="language-wit">record subphrase {
  str: string,
  idx: s32
}
split-str: func(phrase: string, delim: string) -&gt; list&lt;subphrase&gt;
</code></pre>
<p>Now we’re ready to write some code.</p>
<ul>
<li>If you'd like to learn about implementing this example in C++, please look <a href="Tutorial-Impl-CPP-Split.html">here</a>.</li>
<li>If you'd like to learn about implementing this example in Rust, please look <a href="Tutorial-Impl-Rust-Split.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation-and-compilation"><a class="header" href="#implementation-and-compilation">Implementation and Compilation</a></h1>
<ul>
<li>To see how to implement and compile a Wasm function in C/C++, please look <a href="Tutorial-Impl-CPP.html">here</a>.</li>
<li>To see how to implement and compile a Wasm function in Rust, please look <a href="Tutorial-Impl-Rust.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-and-compiling-examples-in-cc"><a class="header" href="#implementing-and-compiling-examples-in-cc">Implementing and Compiling Examples in C/C++</a></h1>
<ul>
<li>To see how to implement and compile the <code>power-of</code> example in C, please look <a href="Tutorial-Impl-CPP-Power.html">here</a>.</li>
<li>To see how to implement and compile the <code>split-str</code> example in C++, please look <a href="Tutorial-Impl-CPP-Split.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-the-power-of-example-in-c"><a class="header" href="#implementing-the-power-of-example-in-c">Implementing the <code>power-of</code> Example in C</a></h1>
<h2 id="generating-bindings"><a class="header" href="#generating-bindings">Generating Bindings</a></h2>
<p>For the C language, we’ll need to explicitly generate language bindings for our functions. We can do this using the <a href="https://bytecodealliance.github.io/wit-bindgen/"><code>wit-bindgen</code></a> program. In your work directory, run the following command:</p>
<pre><code>wit-bindgen c --export power.wit
</code></pre>
<p>This will generate two files in your work directory:  <code>power.c</code> and <code>power.h</code>.</p>
<p>If you look at the contents of the <code>power.h</code> file, you’ll see a single prototype:</p>
<pre><code class="language-cpp">int32_t power_power_of(int32_t base, int32_t exp);
</code></pre>
<p>The name looks odd because wit-bindgen concatenates the name of the WIT file with the name of the function. That’s ok; as we’ll see in a moment, the name that is actually exported will make more sense.</p>
<p>Aside from the function name, the signature is as expected:  take two 32-bit integers, and return one.</p>
<p>Next, open the <code>power.c</code> file in your editor. We’ll ignore the <code>canonical_abi_realloc</code> and <code>canonical_abi_free</code> functions for now and skip to the bottom where we will find a function called <code>__wasm_export_power_power_of</code>. This is wrapper code that handles passing values through the Wasm Canonical ABI (a trivial operation in this case). Looking at the body of this function, we can see that it calls the <code>power_power</code> function that was declared in the header file. We’ll need to provide the implementation for this.</p>
<p>Before we continue, though, notice the following line just above the this function’s definition:</p>
<pre><code class="language-cpp">__attribute__((export_name(&quot;power-of&quot;)))
</code></pre>
<p>This line forces the name of this wrapper function be exported from the compiled module as power-of (the hyphen is the preferred word separator for function names in Wasm). Fortunately, consumers only need to invoke it by this name.</p>
<h2 id="implementing-and-compiling"><a class="header" href="#implementing-and-compiling">Implementing and Compiling</a></h2>
<p>Now, let’s implement the logic we need. To the bottom of the <code>power.c</code> file, add the following code (we can start by copying in the prototype from the <code>power.h</code> file):</p>
<pre><code class="language-cpp">int32_t power_power_of(int32_t base, int32_t exp)
{
    int32_t res = 1;
    for (int32_t i = 0; i &lt; exp; ++i)
    {
        res *= base;
    }
    return res;
}
</code></pre>
<p>Now let’s save the file and get back to our command line.</p>
<p>We can compile this program into a Wasm module by using the following command.</p>
<pre><code class="language-bash">clang                            \
    --target=wasm32-unknown-wasi \
    -mexec-model=reactor         \
    -I.                          \
    -o power.wasm                \
    power.c
</code></pre>
<p>You should now see a <code>power.wasm</code> file in your directory.</p>
<p>Next, we'll do some <a href="Tutorial-Test-Power.html">testing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-the-split-str-example-in-c"><a class="header" href="#implementing-the-split-str-example-in-c">Implementing the <code>split-str</code> example in C++</a></h1>
<h2 id="generating-bindings-1"><a class="header" href="#generating-bindings-1">Generating Bindings</a></h2>
<p>In this example, we’ll use C++ so that we can leverage the STL’s higher-level data structures and keep our implementation focused on the big picture as much as possible.</p>
<p>As before, we’ll start by generating the C language bindings. Run the <em>wit-bindgen</em> command:</p>
<pre><code class="language-bash">wit-bindgen c --export split.wit
</code></pre>
<p>There should now be a <code>split.c</code> and <code>split.h</code> file in your work directory. Since we’ll be using C++, rename <code>split.c</code> to <code>split.cpp</code>:</p>
<h2 id="implementing-and-compiling-1"><a class="header" href="#implementing-and-compiling-1">Implementing and Compiling</a></h2>
<p>Since we’ll be using C++, rename <code>split.c</code> to <code>split.cpp</code>:</p>
<pre><code class="language-bash">mv split.c split.cpp
</code></pre>
<p>Now let’s take a look at <code>split.h</code>. As we might expect, there are a few more definitions in here than in the simpler <code>power-of</code> example. The wit-bindgen program has generated a struct definition for us to use when passing our strings, as well as ones for the subphrase record and its enclosing list. At the bottom is prototype for the function we are going to implement:</p>
<pre><code class="language-cpp">void split_split_str(split_string_t *phrase, split_string_t *delim, split_list_subphrase_t *ret0);
</code></pre>
<p>This, too, looks a bit different than in the <code>power-of</code> example. For one thing, the function doesn’t return a value. Since this function will be returning a list, for which we’ll need to dynamically allocate memory, the result is passed as an argument pointer instead.</p>
<p>Now let’s open up the <code>split.cpp</code> file. Once again, we are going to add our implementation here. At the bottom of the file, we can find the generated wrapper function, called <code>__wasm_export_split_split_str</code>. This wrapper delegates to the function we will be implementing, and we also can see that it is doing work required for lifting and lowering the data types on either side of the function call.</p>
<p>We’ll now add our code. Let’s first update the top of <code>split.cpp</code> as follows:</p>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;split.h&gt;
</code></pre>
<p>Since C++ has a more strict compiler than C, we’ll also need to make a small change to the generated code in this file at line 38. Go ahead and change the following line:</p>
<pre><code class="language-cpp">ret-&gt;ptr = canonical_abi_realloc(NULL, 0, 1, ret-&gt;len);
</code></pre>
<p>... to this:</p>
<pre><code>ret-&gt;ptr = reinterpret_cast&lt;char *&gt;(canonical_abi_realloc(NULL, 0, 1, ret-&gt;len));
</code></pre>
<p>And finally, to the bottom of the file, we’ll add this chunk of code:</p>
<pre><code class="language-cpp">void split_split_str(split_string_t *phrase, split_string_t *delim, split_list_subphrase_t *ret0)
{
    // Clear the result.
    memset(ret0, 0, sizeof(split_list_subphrase_t));

    // Parse the tokens.
    std::string phr(phrase-&gt;ptr, phrase-&gt;len);
    std::string dlm(delim-&gt;ptr, delim-&gt;len);
    std::string tok;
    std::vector&lt;std::pair&lt;std::string, size_t&gt;&gt; subs;
    size_t start = 0, end = 0;
    if (delim-&gt;len)
    {
        while ((end = phr.find(dlm, start)) != std::string::npos)
        {
            tok = phr.substr(start, end - start);
            subs.push_back(std::pair&lt;std::string, size_t&gt;(tok, start));
            start = end + dlm.length();
        }
    }
    subs.push_back(std::pair&lt;std::string, size_t&gt;(phr.substr(start), start));

    // Populate the result.
    bool err = false;
    auto res = (split_subphrase_t *) malloc(phr.size() * sizeof(split_subphrase_t));
    for (int i = 0; !err &amp;&amp; i &lt; subs.size(); ++i)
    {
        auto&amp; sub = subs[i].first;
        res[i].idx = static_cast&lt;int32_t&gt;(subs[i].second);
        res[i].str.len = sub.length();
        res[i].str.ptr = strdup(sub.c_str());
        if (!res[i].str.ptr)
            err = true;
    }

    // If success, assign the result. Else, clean up and return an empty list.
    if (!err)
    {
        // Success; assign the result.
        ret0-&gt;ptr = res;
        ret0-&gt;len = subs.size();
    }
    else
    {
        if (res)
        {
            for (int i = 0; i &lt; subs.size(); ++i)
                if (res[i].str.ptr)
                    free(res[i].str.ptr);
            free(res);
        }
    }

    // Per the Canonical ABI contract, free the input pointers.
    free(phrase-&gt;ptr);
    free(delim-&gt;ptr);
}
</code></pre>
<p>There is much more work going on here than in the <a href="Tutorial-Impl-CPP-Power.html"><code>power-of</code></a> example; a fair amount of it deals with memory management.</p>
<p>The Wasm Canonical ABI requires that any dynamic memory passed from the host to the guest or vice-versa transfers the ownership to the receiver. This explains the last two lines of our <code>split_split_str</code> function, where we free the pointers to the strings we have been passed as arguments. This memory will have been allocated by the host using our guest module’s exported <code>canonical_abi_realloc</code> function, which takes it from the Wasm instance’s linear memory at runtime. Conversely, you may also notice that we pass dynamically allocated memory out of the function; the host is expected to free it by calling our module's <code>canonical_abi_free</code> routine, which will return it to the linear memory.</p>
<p>Now let’s save the file and build the module. We will use a similar approach as we did in the simple example above, but with a couple of tweaks. First, we’ll use clang++, since this is C++ code. And second, we’ll need to include the option <code>-fno-exceptions</code> because Wasm doesn’t yet support exception handling (there is a proposal, however).</p>
<pre><code class="language-bash">clang++                          \
    -fno-exceptions              \
    --target=wasm32-unknown-wasi \
    -mexec-model=reactor         \
    -s                           \
    -I.                          \
    -o split.wasm                \
    split.cpp
</code></pre>
<p>As expected, there should now be a <code>split.wasm</code> file in your work directory.</p>
<p>Next, we'll do some <a href="Tutorial-Test-Split.html">testing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-and-compiling-examples-in-rust"><a class="header" href="#implementing-and-compiling-examples-in-rust">Implementing and Compiling Examples in Rust</a></h1>
<ul>
<li>To see how to implement and compile the <code>power-of</code> example in Rust, please look <a href="Tutorial-Impl-Rust-Power.html">here</a>.</li>
<li>To see how to implement and compile the <code>split-str</code> example in Rust, please look <a href="Tutorial-Impl-Rust-Split.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-a-simple-example-in-rust"><a class="header" href="#developing-a-simple-example-in-rust">Developing a Simple Example in Rust</a></h1>
<h2 id="initialize-your-source-tree"><a class="header" href="#initialize-your-source-tree">Initialize Your Source Tree</a></h2>
<p>From within a new work directory, run <code>cargo init --vcs none --lib</code>. This will set up a skeletal Rust source tree.</p>
<p>We’ll need the <code>power.wit</code> file we created <a href="Tutorial-WIT-Power.html">earlier</a>. Copy it into this directory if it is not already there.</p>
<h2 id="implementing-and-compiling-2"><a class="header" href="#implementing-and-compiling-2">Implementing and Compiling</a></h2>
<p>Now, edit the file called <code>Cargo.toml</code> so that it looks like the following:</p>
<pre><code class="language-toml">[package]
name = &quot;power&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
wit-bindgen-rust = { git = &quot;https://github.com/bytecodealliance/wit-bindgen.git&quot;, rev = &quot;60e3c5b41e616fee239304d92128e117dd9be0a7&quot; }

[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>Now we’re almost ready to roll. Edit the file <code>src/lib.rs</code> and replace its content with this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wit_bindgen_rust::export!(&quot;power.wit&quot;);
struct Power;

impl power::Power for Power {
    fn power_of(base: i32, exp: i32) -&gt; i32 {
        let mut res = 1;
        for _i in 0..exp {
            res *= base;
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax at the top of the code is boiler-plate. The export macro generates code that declares a trait named after our WIT file (and some other things). So, our main job is here is to implement this trait. If you are curious what the macro actually generates, you can run cargo expand and it will show you the fully expanded source code.</p>
<p>The WIT IDL is heavily inspired by the Rust language syntax, so it was pretty easy to derive the Rust function signature we needed from the IDL:</p>
<ul>
<li>
<p>Replaced hyphens with underscores</p>
</li>
<li>
<p>Changed s32 types to i32</p>
</li>
</ul>
<p>Now we can compile the program into a wasm module using this command:</p>
<pre><code class="language-bash">cargo wasi build --lib
</code></pre>
<p>The new Wasm file should be written to <code>target/wasm32-wasi/debug/power.wasm</code>.</p>
<p>Next, we'll do some <a href="Tutorial-Test-Power.html">testing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-a-more-complex-udf-in-rust"><a class="header" href="#developing-a-more-complex-udf-in-rust">Developing a More Complex UDF in Rust</a></h1>
<h1 id="initialize-your-source-tree-1"><a class="header" href="#initialize-your-source-tree-1">Initialize Your Source Tree</a></h1>
<p>Start by creating a new work directory and initializing it using <code>cargo init --vcs none --lib</code>.</p>
<p>We'll need the <code>split.wit</code> file we created <a href="Tutorial-WIT-Split.html">earlier</a>.  Copy it into this directory if it is not already there.</p>
<h3 id="implementing-and-compiling-3"><a class="header" href="#implementing-and-compiling-3">Implementing and Compiling</a></h3>
<p>Much of this will be similar to the techniques we used in the <a href="Tutorial-Impl-Rust-Power.html"><code>power-of</code> example</a>.</p>
<p>Edit the <code>Cargo.toml</code> file so it looks like this:</p>
<pre><code class="language-toml">[package]
name = &quot;split&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
wit-bindgen-rust = { git = &quot;https://github.com/bytecodealliance/wit-bindgen.git, rev = &quot;60e3c5b41e616fee239304d92128e117dd9be0a7&quot; }

[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>And, for the implementation, edit the <code>src/lib.rs</code> file and replace its contents with this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wit_bindgen_rust::export!(&quot;split.wit&quot;);
struct Split;
use crate::split::Subphrase;

impl split::Split for Split {

    fn split_str(phrase: String, delim: String) -&gt; Vec&lt;Subphrase&gt; {
        phrase
            .split(&amp;delim)
            .scan(0, |idx, s| {
                let current = Subphrase {
                    str: s.to_string(),
                    idx: *idx as i32
                };
                *idx += (s.len() + delim.len()) as i32;
                Some(current)
            })
            .collect()
    }
} 
<span class="boring">}
</span></code></pre></pre>
<p>Fortunately, with Rust, we have some nice language features that help make our code concise. Unlike in <a href="Tutorial-Impl-CPP-Split.html"><code>C/C++</code></a>, we don’t need to explicitly free the parameters. Due to Rust’s move semantics, they will be freed implicitly when the function ends. Allocation for the output vector is also managed “under the hood” by Rust’s robust data structures and runtime. Finally, the declaration of the Subphrase struct happens via the <code>wit_bindgen_rust::export macro</code>, so we don’t need to do it.</p>
<p>Let’s compile the Wasm module now:</p>
<pre><code class="language-bash">cargo wasi build --lib
</code></pre>
<p>The new Wasm file should be written to <code>target/wasm32-wasi/debug/split.wasm</code>.</p>
<p>Next, we'll do some <a href="Tutorial-Test-Split.html">testing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<ul>
<li>To see how to test the <code>power-of</code> example, please look <a href="Tutorial-Test-Power.html">here</a>.</li>
<li>To see how to test the <code>split-str</code> example, please look <a href="Tutorial-Test-Split.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED FILE; DO NOT CHANGE! -->
<h1 id="testing-the-power-of-example"><a class="header" href="#testing-the-power-of-example">Testing the <code>power-of</code> Example</a></h1>
<p>The <code>writ</code> utility provides a convenient way for us to test our Wasm function in isolation before we load it into the database.  It accepts JSON-formatted arguments on the command-line, casts them to the actual types defined in the Wasm function, and then passes them in.</p>
<p>Let's make sure our <code>power-of</code> program is working correctly by doing a few spot-tests.  The examples below assume that the <code>power.wasm</code> file exists in the current directory.  If you are using a Rust build, your Wasm file will be located at <code>target/wasm32-wasi/debug/power.wasm</code>.</p>
<pre><code>$ writ --wit power.wit ./power.wasm power-of 2 3
8

$ writ --wit power.wit ./power.wasm power-of 2 0
1

$ writ --wit power.wit ./power.wasm power-of 0 0
1

$ writ --wit power.wit ./power.wasm power-of 0 2
0

$ writ --wit power.wit ./power.wasm power-of 2 -3
1
</code></pre>
<p>Except for the last attempt, the function seems to work correctly.  To keep this example simple, we'll just assume that negative exponents won't be provided.</p>
<p>Now, we're ready to <a href="Tutorial-Deploy-Power.html">deploy</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED FILE; DO NOT CHANGE! -->
<h1 id="testing-the-split-str-example"><a class="header" href="#testing-the-split-str-example">Testing the <code>split-str</code> Example</a></h1>
<p>The <code>writ</code> utility provides a convenient way for us to test our Wasm function in isolation before we load it into the database.  It accepts JSON-formatted arguments on the command-line, casts them to the actual types defined in the Wasm function, and then passes them in.</p>
<p>Let's make sure our <code>split-str</code> program is working correctly by doing a few spot-tests.  The examples below assume that the <code>split.wasm</code> file exists in the current directory.  If you are using a Rust build, your Wasm file will be located at <code>target/wasm32-wasi/debug/split.wasm</code>.</p>
<pre><code>$ writ --wit split.wit ./split.wasm split-str 'hello_you_fine_folks' '_'
[
  {
    &quot;str&quot;: &quot;hello&quot;,
    &quot;idx&quot;: 0
  },
  {
    &quot;str&quot;: &quot;you&quot;,
    &quot;idx&quot;: 6
  },
  {
    &quot;str&quot;: &quot;fine&quot;,
    &quot;idx&quot;: 10
  },
  {
    &quot;str&quot;: &quot;folks&quot;,
    &quot;idx&quot;: 15
  }
] 
</code></pre>
<p>Let's try a couple of edge cases as well.</p>
<pre><code>$ writ --wit split.wit ./split.wasm split-str 'hello' '_'
[
  {
    &quot;str&quot;: &quot;hello&quot;,
    &quot;idx&quot;: 0
  }
]

$ writ --wit split.wit split.wasm split-str 'hello--there-' '-'
[
  {
    &quot;str&quot;: &quot;hello&quot;,
    &quot;idx&quot;: 0
  },
  {
    &quot;str&quot;: &quot;&quot;,
    &quot;idx&quot;: 6
  },
  {
    &quot;str&quot;: &quot;there&quot;,
    &quot;idx&quot;: 7
  },
  {
    &quot;str&quot;: &quot;&quot;,
    &quot;idx&quot;: 13
  }
]
</code></pre>
<p>Looks good!</p>
<p>Now, we're ready to <a href="Tutorial-Deploy-Split.html">deploy</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-examples-into-singlestoredb"><a class="header" href="#deploying-examples-into-singlestoredb">Deploying Examples into SingleStoreDB</a></h1>
<ul>
<li>For information on deploying the <code>power-of</code> example, please look <a href="Tutorial-Deploy-Power.html">here</a>.</li>
<li>For information on deploying the <code>split-str</code> example, please look <a href="Tutorial-Deploy-Split.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED FILE; DO NOT CHANGE! -->
<h1 id="deploying-the-power-of-example"><a class="header" href="#deploying-the-power-of-example">Deploying the <code>power-of</code> Example</a></h1>
<p>Now that you've compiled and tested your Wasm function, it is ready for deployment into the database.  This can be done in multiple ways.  The easiest is probably to use the <code>pushwasm</code> tool, included in the <code>wasm-toolkit</code> development containers.  Alternatively, you can &quot;pull&quot; the Wasm module into the database by first uploading it to cloud storage (SingleStoreDB supports pulling Wasm modules from multiple cloud providers -- GCS, Azure, and S3).  We'll discuss both techniques.</p>
<p>Before we start, ensure that a destination database is available.  To do this, using your favorite SQL client, create a new database called <code>wasm_tutorial</code>.  For example, you might use the following statements:</p>
<pre><code class="language-sql">CREATE DATABASE wasm_tutorial;
USE wasm_tutorial;
</code></pre>
<ul>
<li>To deploy the <code>power-of</code> example using the <code>pushwasm</code> tool, please see <a href="Tutorial-Deploy-Power-Push.html">here</a>.</li>
<li>To deploy the <code>power-of</code> example from cloud storage, please see <a href="Tutorial-Deploy-Power-Cloud.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-power-of-using-pushwasm"><a class="header" href="#deploying-power-of-using-pushwasm">Deploying <code>power-of</code> Using <code>pushwasm</code></a></h1>
<p>The <code>pushwasm</code> tool will upload our WIT file and compiled Wasm module into the database.  To use it, we'll need the following information.  Since this depends highly on your specific environment, we'll just make some generic assumptions about their values.</p>
<ul>
<li>The hostname of the SingleStoreDB server (we'll call this <code>myserver</code>)</li>
<li>The destination database name (we'll call this <code>wasm_tutorial</code>)</li>
<li>The user ID and password of the database user (we'll call this user <code>admin</code>)</li>
<li>The path to the compiled Wasm module (we'll use <code>./power.wasm</code> below, but for the Rust example, you should use located in <code>target/wasm32-wasi/debug/power.wasm</code> instead)</li>
<li>The path to the WIT file</li>
</ul>
<p>Now, run the following command from within your work directory:</p>
<pre><code class="language-bash">pushwasm --prompt --wit ./power.wit mysql://admin@myserver/wasm_tutorial ./power.wasm power_of
</code></pre>
<p>The <code>--prompt</code> option will cause a prompt to appear, where you can enter your database user's password.</p>
<p>When the deployment has completed, you should see the following:</p>
<pre><code class="language-console">Wasm UDF 'power_of' was created successfully.
</code></pre>
<p>Finally, we're ready to <a href="Tutorial-Running-Power.html">run the UDF</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-power-of-from-cloud-storage"><a class="header" href="#deploying-power-of-from-cloud-storage">Deploying <code>power-of</code> From Cloud Storage</a></h1>
<p>You'll need the following information to do this:</p>
<ul>
<li>The path to the compiled Wasm module (we'll use <code>./power.wasm</code> below, but for the Rust example, you should use located in <code>target/wasm32-wasi/debug/power.wasm</code> instead)</li>
<li>The path to the WIT file</li>
<li>Your cloud storage credentials and path (we'll assume an S3 bucket called <code>wasm-modules</code>).</li>
</ul>
<p>From your work directory, you'll need to upload your WIT (<code>./power.wit</code>) and compiled Wasm (<code>.wasm</code>) files to a bucket to the <code>wasm-modules</code> S3 bucket.</p>
<p>Now, connect to the database from your SQL client and run the following statement to pull the module from S3 into the <code>wasm_tutorial</code> database:</p>
<pre><code class="language-sql">CREATE FUNCTION power_of AS WASM 
FROM S3 'wasm-modules/power.wasm'
    CREDENTIALS '{
        &quot;aws_access_key_id&quot;: &quot;ASIAZPIKLSJ3HM7FKAUB&quot;,
        &quot;aws_secret_access_key&quot;: FwoGZXIvYXdzEL3fv [...]&quot;
    }'
    CONFIG '{&quot;region&quot;: &quot;us-east-1&quot;}'
WITH WIT FROM S3 'wasm-modules/power.wit'
    CREDENTIALS '{
        &quot;aws_access_key_id&quot;: &quot;ASIAZPIKLSJ3HM7FKAUB&quot;, 
        &quot;aws_secret_access_key&quot;: FwoGZXIvYXdzEL3fv [...]&quot;
    }' 
    CONFIG '{&quot;region&quot;: &quot;us-east-1&quot;}';
</code></pre>
<p>If the UDF has been created successfully, you will see something like:</p>
<pre><code class="language-console">Query OK, 1 row affected (0.029 sec)
</code></pre>
<p>Finally, we're ready to <a href="Tutorial-Running-Power.html">run the UDF</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED FILE; DO NOT CHANGE! -->
<h1 id="deploying-the-split-str-example"><a class="header" href="#deploying-the-split-str-example">Deploying the <code>split-str</code> Example</a></h1>
<p>Now that you've compiled and tested your Wasm function, it is ready for deployment into the database.  This can be done in multiple ways.  The easiest is probably to use the <code>pushwasm</code> tool, included in the <code>wasm-toolkit</code> development containers.  Alternatively, you can &quot;pull&quot; the Wasm module into the database by first uploading it to cloud storage (SingleStoreDB supports pulling Wasm modules from multiple cloud providers -- GCS, Azure, and S3).  We'll discuss both techniques.</p>
<p>Before we start, ensure that a destination database is available.  To do this, using your favorite SQL client, create a new database called <code>wasm_tutorial</code>.  For example, you might use the following statements:</p>
<pre><code class="language-sql">CREATE DATABASE wasm_tutorial;
USE wasm_tutorial;
</code></pre>
<ul>
<li>To deploy the <code>split-str</code> example using the <code>pushwasm</code> tool, please see <a href="Tutorial-Deploy-Split-Push.html">here</a>.</li>
<li>To deploy the <code>split-str</code> example from cloud storage, please see <a href="Tutorial-Deploy-Split-Cloud.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-split-str-using-pushwasm"><a class="header" href="#deploying-split-str-using-pushwasm">Deploying <code>split-str</code> Using <code>pushwasm</code></a></h1>
<p>The <code>pushwasm</code> tool will upload our WIT file and compiled Wasm module into the database.  To use it, we'll need the following information.  Since this depends highly on your specific environment, we'll just make some generic assumptions about their values.</p>
<ul>
<li>The hostname of the SingleStoreDB server (we'll call this <code>myserver</code>)</li>
<li>The destination database name (we'll call this <code>wasm_tutorial</code>)</li>
<li>The user ID and password of the database user (we'll call this user <code>admin</code>)</li>
<li>The path to the compiled Wasm module (we'll use <code>./power.wasm</code> below, but for the Rust example, you should use located in <code>target/wasm32-wasi/debug/power.wasm</code> instead)</li>
<li>The path to the WIT file</li>
</ul>
<p>Now, run the following command from within your work directory.  Unlike the <a href="Tutorial-Deploy-Power-Push.html"><code>power-of</code></a> example, we'll deploy the <code>split-str</code> function as a Table-Valued Function (TVF).  This will require us to pass the <code>--tvf</code> flag.</p>
<pre><code class="language-bash">pushwasm --tvf --prompt --wit ./split.wit mysql://admin@myserver/wasm_tutorial ./split.wasm split_str
</code></pre>
<p>The <code>--prompt</code> option will cause a prompt to appear, where you can enter your database user's password.</p>
<p>When the deployment has completed, you should see the following:</p>
<pre><code class="language-console">Wasm TVF 'split_str' was created successfully.
</code></pre>
<p>Finally, we're ready to <a href="Tutorial-Running-Split.html">run the TVF</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-split-str-from-cloud-storage"><a class="header" href="#deploying-split-str-from-cloud-storage">Deploying <code>split-str</code> From Cloud Storage</a></h1>
<p>You'll need the following information to do this:</p>
<ul>
<li>The path to the compiled Wasm module (we'll use <code>./split.wasm</code> below, but for the Rust example, you should use located in <code>target/wasm32-wasi/debug/split.wasm</code> instead)</li>
<li>The path to the WIT file</li>
<li>Your cloud storage credentials and path (we'll assume an S3 bucket called <code>wasm-modules</code>).</li>
</ul>
<p>From your work directory, you'll need to upload your WIT (<code>./split.wit</code>) and compiled Wasm (<code>./split.wasm</code>) files to a bucket to the <code>wasm-modules</code> S3 bucket.</p>
<p>Now, connect to the database from your SQL client and run the following statement to pull the module from S3 into the <code>wasm_tutorial</code> database.  Note that unlike the <a href="Tutorial-Deploy-Power-Cloud.html"><code>power-of</code></a> example, we'll be deploying this <code>split-str</code> function as a Table-Valued Function (TVF).  This will require us to include the <code>RETURNS TABLE</code> clause.</p>
<pre><code class="language-sql">CREATE FUNCTION split_str RETURNS TABLE AS WASM 
FROM S3 'wasm-modules/split.wasm'
    CREDENTIALS '{
        &quot;aws_access_key_id&quot;: &quot;ASIAZPIKLSJ3HM7FKAUB&quot;,
        &quot;aws_secret_access_key&quot;: FwoGZXIvYXdzEL3fv [...]&quot;
    }'
    CONFIG '{&quot;region&quot;: &quot;us-east-1&quot;}'
WITH WIT FROM S3 'wasm-modules/split.wit'
    CREDENTIALS '{
        &quot;aws_access_key_id&quot;: &quot;ASIAZPIKLSJ3HM7FKAUB&quot;, 
        &quot;aws_secret_access_key&quot;: FwoGZXIvYXdzEL3fv [...]&quot;
    }' 
    CONFIG '{&quot;region&quot;: &quot;us-east-1&quot;}';
</code></pre>
<p>If the TVF has been created successfully, you will see something like:</p>
<pre><code class="language-console">Query OK, 1 row affected (0.029 sec)
</code></pre>
<p>Finally, we're ready to <a href="Tutorial-Running-Split.html">run the TVF</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-in-the-database"><a class="header" href="#running-in-the-database">Running In the Database</a></h1>
<ul>
<li>To see how to run the <code>power_of</code> UDF, please look <a href="Tutorial-Running-Power.html">here</a>.</li>
<li>To see how to run the <code>split_str</code> TVF, please look <a href="Tutorial-Running-Split.html">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-in-the-database-1"><a class="header" href="#running-in-the-database-1">Running In the Database</a></h1>
<p>Hooray, we can now run our Wasm function in the database!</p>
<p>When we imported our function, the database automatically converted the hyphen
s (<code>-</code>) in our function name to underscores (<code>_</code>).  So, <code>power-of</code> is now a UDF called <code>power_of</code>.</p>
<p>Using the following syntax, we can run it as a UDF:</p>
<pre><code class="language-sql">SELECT power_of(2, 8);
</code></pre>
<p>... which should return a single-column row with the value <code>256</code>.</p>
<p>Neat!</p>
<p>Let's <a href="Tutorial-WrapUp.html">review what we've learned</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-in-the-database-2"><a class="header" href="#running-in-the-database-2">Running In the Database</a></h1>
<p>Hooray, we can now run our Wasm function in the database!</p>
<p>When we imported our function, the database automatically converted the hyphens (<code>-</code>) in our function name to underscores (<code>_</code>).  So, <code>split-str</code> is now a UDF called <code>split_str</code>.</p>
<p>Using the following syntax, we can run our function as a TVF:</p>
<pre><code class="language-sql">SELECT * FROM split_str('wasm_rocks_the_house', '_');
</code></pre>
<p>... which will produce the following output:</p>
<pre><code class="language-console">+-------+-----+
| str   | idx |
+-------+-----+
| wasm  |   0 |
| rocks |   5 |
| the   |  11 |
| house |  15 |
+-------+-----+
94 rows in set (0.001 sec)
</code></pre>
<p>Awesome!</p>
<p>Let's <a href="Tutorial-WrapUp.html">review what we've learned</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-up"><a class="header" href="#wrap-up">Wrap-Up</a></h1>
<p>Well, this concludes our little tutorial.  In this tutorial, we learned how to turn some simple use cases into WebAssembly programs.  We then examined how to test them, load them into SingleStoreDB, and run them there.</p>
<p>Hopefully, this helps you kickstart the creation of your own Wasm UDFs and TVFs.  Thanks for tuning in!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
